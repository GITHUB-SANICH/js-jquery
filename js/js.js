//#1.1 - Теоретическая лекция
console.log('');
console.log('#1.1 - Теоретическая лекция');
/*Введение:
	В этой части курса - все нужные сведения находятся в презентации.
	Там говорится о переменных, массивах, объектах, типах данных, JSON и т.д.
	
	JSON
	Обычно испольщуется для передачи через API запросы.
	Обращаться к значениям JSON можно, когда он переведен в объект. 
	Перенесение данных объекта возможно, только в формате JSON. 
		JSON.parse		- функция перевода JSON в объект
		JSON.stringify	- функция перевода объекта в JSON

	DOM - инструмент обращения к HTML елементам страницы
	BOM - надстройка/окрущение JS, которое вмещает в себя функционал работы с браузером. 
	
	Метод окружения BOM: XMLHttpRequest	- нативный аналог асинхонного программировнаия в JS - аналог Ajax. 
*/

//#1.2 - Подключение и настройка
console.log('');
console.log('#1.2 - Подключение и настройка');
console.log('Hello World');
/*Введение:
	Создание папок и файлов:
		Создаем HTML aфайл и создаем в нем структуру. 
		СОздадим CSS папку и файл, подключив его к HTML. 

	Подключение JS:
		JS по-умолчению работает во всех браузерах. 
		Нужно прописать тег "<script></script>", в котором работает JS. Но лучше создавать файл и подключать его к html. => <script src="js/index.js"></script>

		ВАЖНО! Код JS ставится в самом нижу стрницы перед <body>, чтобы не тормозить страницу. 
		1) Так как JS работает с елементами страницы, то нужно, чтобы эти елементы страницы сначала отобразились, чтобы к ним можно было обращаться. 
			Иначе JS будет висеть в браузере и ждать отображения елементов, что отобразиться на производительности. 
		2) JS скрипты бывают объемными, поэтому их оставляют на потом, чтобы страницы успеле отобразиться. 

	ASYNC 
	ASYNC - это атребут, позволяющий асинхронно загружать скрипт. 
		Этот атребут дающий приоритет загрузки скрипту паралельно со страницей. Им лучше не злоупотреблять.   
		Пример: 
			<script async src="js/index.js"></script>
*/


//#1.3 - Переменные, типы данных
console.log('');
console.log('#1.3 - Переменные, типы данных');
/*Введение:
ОБЪЯВЛЕНИЕ ПЕРЕМЕННОЙ
	var	- просто переменная
	let	- переменная с областью видемости (понятнее будет с функциями и циклами). Это более валидный и предпочтительный вариант объявления переменной. 
		Переменная, объявленная через let, видна только в рамках блока {...}, в котором объявлена.
	const	- переменная, значение которой в последующем нельзя изменить.

	Примеры:
		var myFirstVar = 'Shalom'; - объявление переменной		
			myFirstVar = 'Shalom'; - переприсваивание уже созданной переменной		

		var mySecondVar = 'Hello'; - объявление переменной
			mySecondVar = 'Hello'; - переприсваивание уже созданной переменной
	Важно! 
		1) Переприсваивание работает только при наличии ранее созданной переменной.
			В случаи с созданием переменной var после - ошибка не будет выведена, но она будет. В случаи с let - ошибка будет выведена. 
		2) Создание двух переменных с одинаковым названием недопустимо. В случаи с var - ошибка не отобразится, но с let - ошибка отобразится.
		3) Переприсваивание переменной "const" после объявления - приведет к ошибке. 
		4) Переменныйе с неидентичным регистром - считаюстя разными => var num; != var Num; 

	Вывод переменной:
		console.log('Переменная: ' + myFirstVar);
		где,
			'Переменная: ' - строка
			+ - знак конкатонации в JS
			myFirstVar - название выводимой переменной

		Типы данных:
			var natting = null; 	//0 == ''
			var natting;  			//underfined == неопределенное значение
			var obj = {};			//объект
*/

//var myFirstVar = 'Shalom'; //объявление переменной
//var mySecondVar = 'Hello'; //объявление переменной
myFirstVar = 'Shalom - Shabat'; // переприсваивание уже созданной переменной
	// Важно! Переприсваивание работает только при наличии ранее созданной переменной.
//вывод переменной
console.log('Переменная: ' + myFirstVar);

//#1.4 - Математические операторы
/*Введение:
	Создадим новый файл "js\vars.js" и подключем его перед файлом "js\index.js".
	В первом файле пропишем переменные, а во втором выведем их. Сработает все нормально;
		Первый файл:
			let x = 56; let y = 10; let res;
		Второй файл:
			console.log(x + " " + y);
		Если файлы подключить в обратном порядке - выведется ошибка. Потому, что в браузере код читсается свурху вниз. 
*/	
console.log('');
console.log('#1.4 - Математические операторы');
let x = 56;
let y = 10;
let res;

res = x + y;
console.log('Результат сложения: ' + res);
res = x / y;
console.log('Результат деления: ' + res);
res = x % y;
console.log('Остаток при делении: ' + res);
res += 10;
console.log('Сложение 10 с результатом: ' + res);
res = -res; //минус на минус дает плюс
console.log('Унарный минус: ' + res);

//let str_1 =	'Hello ';
//let str_2 =	'World';
//console.log('Сложение строк: ' + (str_1 + str_2)); //круглые скобки подчеркивают, что знак "+" - это знак сложения, а не канкотанации.

//#1.5 - Условные операторы (3 типа условий)
console.log('');
console.log('#1.5 - Условные операторы (3 типа условий)');
//let x = 20;
//let y = 10;
//let hasCar = true;

//if (x != 24 || (!hasCar && y == 24)) { //если все условия в скобке возвратщают true, то условие выполняется
//	console.log('"x" не равен 24');
//}

if (x > y) {
	console.log('"x" больше чем "y"');
} else if (x < y){
	console.log('"y" больше чем "x"');
} else {
	console.log('"y" равен "x"');
}

//оператор switch-case
//let switch_test = 'test';
//в случаи оттсутствия прописи "break;" - цикл продолжит проверять другие условия
//switch (switch_test) {
//	case 'test':
//		console.log('"switch_test" == "test"');
//		break;
//	case 'switch':
//		console.log('"switch_test" == "switch"');
//		break;
//	default:
//		console.log('Переменная не определена');
//		break;
//}

//тернарный оператор
//let numeric = '45';
//let ternar = numeric > 20 ? 'больше' : 'меньше';
//console.log('Результат тернарного оператора: '+ternar);

//#1.6 - Одномерные и многомерные массивы данных
console.log('');
console.log('#1.6 - Одномерные и многомерные массивы данных');
//СОЗДНИЕ МАССИВА И ЕГО ВЫВОД
let array = [
	45,
	true,
	6.92,
	'Hello',
	'R'
];
console.log(array);
console.log('4-й элемент массива: ' + array[3]);

//Создание массива через обращение к классу	
let arr = new Array('5x'); //5x - елемент массива. Просто число - объявляет длинну массива.

//перепресвоение значения
array[2] = 7.62;
array[2] += '*39';
console.log('3-й  перезаписанный элемент массива: ' + array[2]);

//ФУНКЦИИ РАБОТЫ С МАССИВОМ
//1. Функция вывода числа елементов масива - "length".
//вывод числа елементов массива
console.log('Число елементов массива "array": ' + array.length);

//2. Функция удаления последнего елементов масива - "pop".
//Пример удаления последнего елементов массива:
array.pop();

//3. Функция создание элемента после последнего елементов масива - "push".
	//Пример создания елемента массива после последнего:
	array.push('lastElement'); //аргументами выступают добавляемые значения
	array[array.length] = 'lastElement'; //создание для массива нового елемента
	//две верхнии записи - идентичны по логике, но функция "push" - способна принимать несколько параметров

//4. Функция удаления первого елемента из масива - "shift".
	//Пример удаления первого елементов массива:
	array.shift();
		
//5. Функция прибавления первого елемента в масив - "unshift".
	//Пример прибавления первого елемента в массив:
		array.unshift('first_el');
		//при использовании функции - все последующие индексы сдвигаются на +1.
		
		//ВАЖНО! функция array.length - может изменить длинну массива, удаляя лишнии елементы 
			//array.length = 3;
			//console.log('Вывод первых 3-х елементов массива "array": ' + array);
			
//6. Функция очищения указанного индекса в масиве - "delete".
	//Пример прибавления первого елемента в массив:
		delete array[1];
		//при удалении елемента - на его месте останется пустота

//7. Функция создания массива из строки - "split".
	//Пример строки в массив:
		let str_split = 'Shalom, Hy, Qu, Привет';	//строка
		let array_split = str_split.split(", ");	//массив из елементов строки, где ", " - знак разделения елементов массива

//8. Функция создания массива из строки - "join".
	//Пример перевода массива в сроку:
		let array_join = ['1-й', '2-й', '3-й', '4-й'];	//массив
		let str_join = array_join.join("+");	//строка из елементов массива, где "+" - знак через который будут записаны елементы в строку

//9. Функция удаление елементов массива с индекса по индекс - "splice".
	//Пример обрезания массива:
		let array_splice = ['a', 'б', 'в', 'г', 'д'];
		array_splice.splice(2, 4); //где 2 - индекс отчета отрезания, 4 - индекс завершения обрезания
		//Функция может удалить и только один елемент массива

//ДВУМЕРНЫЙ МАССИВ
//Это массив из массивов ... он может быть и трехмерным
let matrix = [
	[577, 'got'],
	[526],
	['root', true, 'true', '5m']
];
//вывод елеменат двумерного массива
matrix[2][0]; //значение первого елемента (0) 3-го массива (2).

console.log('Последний вывод массива "array": ' + array);
console.log('Последний вывод массива "arr": ' + arr);
console.log('Последний вывод двумерного массива "matrix": ' + matrix[2][0]);
console.log('Последний вывод засплитенного массива "array_split": ' + array_split);
console.log('Последний вывод рассплитенной строки "str_join": ' + str_join);
console.log('Последний вывод обрезанного массива "array_splice": ' + array_splice);


//ВАЖНО! При создании например массива с 100-м индексом, когда их только 5 => создается еще 95 пустых индексов после 5-го. Длина массива созрастает до 101 - до элемента. Лучше пустые елементы не создавать, забивая длинну массива.

//#1.7 - Циклы, а также операторы в циклах
console.log('');
console.log('#1.7 - Циклы, а также операторы в циклах');
//for
let array_for = [5, 7, 'Hay', 'is', true];
for (let index = 0; index < array_for.length; index++) {
	console.log('Элемент массива №: '+(index+1)+' => '+ array_for[index]);
}

//while
let i = 1;
while (i < 4) {
	console.log('Вывод иттерации while: '+i);
	i *= 2;
}

//forEach
array_forEach = [78, '4g', 'j7'];
array_forEach.forEach(function (item, i, array_to) {
	console.log('Вывод элемента массива через forEach №: ' + (i+1) + ' => ' + item +
		'. Массив: ' + array_to);
});

/*
	где,
		array_forEach	- название массива
		forEach			- команда цикла
		function			- колбек функция (о ней в уроке о функциях)
		item				- елемент массива
		i					- индекс
		array_to			- псевданим массива
*/

//forin
//forin - это цикл для перебора объектов
for (var key in array_forEach){
	console.log('Элемент выводимого массива через forin №'+ key + ': '+ array_forEach[key]);
}
/*
где, 
	key				- переменная c индексом элемента
	in					- оператор, указывающий на объект в котором перебераются данные
	array_forEach	- массив в котором перебераются данные (потому, что массивы еще не проходили). 
*/

//РАЗНИЦА МЕЖДУ ПЕЕРМЕННЫМИ "var" и "let"
	for (var v = 0; v < 3; v++) {
		console.log('Вывод иттерации for_var в цикле: '+v);
	}
	console.log('Вывод иттерации for_var вне цикла: ' + v);

	/*Тут после цикла выведется ошибка, так как переменная "l", объявленная через "let" - не видна за границей цикла
	for (let l = 0; l < 3; l++) {
		console.log('Вывод иттерации for_let в цикле: '+l);
	}
	console.log('Вывод иттерации for_let вне цикла: ' + l);
	*/


//#1.8 - Работа с функциями
console.log('');
console.log('#1.8 - Работа с функциями');
/*
ФУНКЦИИ ВСТРОЕННЫЕ В JS ИЗ УРОКА:
	multiply 		- функция умножающая аргументы
	setTimeout		- функция вызова функции/кода с задержкой
	clearTimeout	- функция выключения функции setTimeout
	setInterval		- функция периодического зщапуска кодфункции
	clearInterval	- функция отключения периодического запуска кода/функции


ФУНКЦИИ И ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ(из урока "https://www.youtube.com/watch?v=6cKoB5ijaGA"):
	Пример объявления функции:
		function nameFunction(){
			console.log('функция объявлена');
		}
	Пример объявления функционального выражения:
		let nameFunctionVar = function(){
			console.log('функция объявлена');
		};
	Различия в том, что функциб можно вызывать в любом месте кода, а функциональное выражение только после его объявления. 
		Это используется, когда например нужно использовать функцию, написанную в фигурных скобках, вызывать и в остальных местах. 
		Т.е. видимость функции расширяется. Это аналагично в сравнении переменных созданных черех операторы "let" и "var".

КОНТЕКСТ ФУНКЦИЙ (видео: "https://www.youtube.com/watch?v=bO881lHXieQ")
	ВАЖНО! Каждая функция имеет свой контекст - привязку к объекту, который вызывает функцию. 
		Если функция вызывается без объекта, вызывающего ее - то функция принимает в свой контекст глобальный объект windows. 
		
		Свойством объекта может выступать и функция. Функции являющиеся свойствами объектов - нызваются методами.
		const user = {
		name: 'Даниил',
			sayHello(){
				console.log('Привет, я - ${this.name}')
			}
		}
		где,
			this 				- вставка для объекта в к контексте которого находится функция
			name 				- свойство объекта  
			sayHello()		- метод, являющаяся свойством объекта user
			${this.name}	- вывод значения свойства объекта 

			Примеры вызова функции sayHello():	
				Вызов функции без ошибки, так как в контекст функции входит объект user с нужным свойством name
					user.sayHello() 
				Вызов функции с ошибкой, так как функция f не имея никакого объекта в контексте - помещает в контекст по-умолчанию объект windiw
					const f = user.sayHello
					f();
				Развернутый вид функции f():
					const f = user.sayHello;
					const f = function(){
						console.log('Привет, я - ${this.name}')
					}
					Получается тогда в this подставляется объект window, который не имеет свойства name, что и приводит к ошибке.
				Вызов функции с ошибкой №2:
					setTimeout(user.sayHello, 1000)
		
		МЕТОДЫ РАБОТЫ С КОНТЕКСТОМ ФУНКЦИЙ (видео: "https://www.youtube.com/watch?v=bO881lHXieQ")
		Помещение объекта в контекст функции:
			1) call() - функция указания объекта для контекста функции, вызывающей функцию call().
			Первый аргумент обязательный - объект, помещаемый в контекст.
			Второй и далее аргумент необязательный - аргумент для функции дочерней - в примере sayHello(). Например это отчество.
				Для функции можно указать объект вручную, так и через специальную функцию.
				Пример:
					const f = user.sayHello;
					f.call(user, middleName);
					где,
						f 			- функция, в контекст которой кладется определенный объект
						call()	- функция помещения объекта в контекст.  
						user		- объект, который кладется в контекст функции f
						middleName - аргумент метод sayHello (отчество)
					С дополнительнм аргументом метод sayHello мог выглядеть например так:
						sayHello(){
							console.log('Привет, я - ${this.name} ${middleName}')
						}
			2) apply()	- аналог функции call(), но вторым аргументов выступает массив.
					Пример:
						function.call(user, ['отчество']){}
			3) bind()	- функция, привязывающая функцию к контексту объекта. Эта функция встречается чаще чем две предыдущих. 
					Функции call() и apply() используются постоянно при вызове функции, а bind() используется однажды при объявлении функции и в повторном использовании после объявления функции - не нуждается. Функция применившая метод bind() - всегда привязана к указанному контексту.  
					Пример применения:
						const f = user.sayHello.bind(user) ... теперь функция f() имеет контекст 'user' всегда. 
						f() == f.call(user);


	СТРЕЛОЧНЫЕ ФУНКЦИИ (из урока "https://www.youtube.com/watch?v=6cKoB5ijaGA"):
		Стрелочная функция - функция с отсутствующей this - указателем на контекст.
		Стрелочная функция - анонимная функция без имени. Имя ей можно припесать, сделав функциональным выражением. 
		Такая функция берет контекст с ближайшего высшего уровня (у функции родителя), в случаи отсутсвия указанного контекста, а не берет контекст объекта window по-умолчанию.  
		Если бы стрелочная функция была методом объекта user, то в поисках контекста она выходит из контекста объекта user и брала внешний контекст window. Поэтому СФ не годятся в свойства объекта. 
		Эта особенность удобна тем, что функция, используящая стрелочную функцию в качестве аргумента принимает контекст уровнем выше, а не контекст прописанный по умолчанию в случаи его отсутствия. Например контекст объекта window по-умолчанию.
		Пример:
			const user = {
				names: ['Даниил 1', 'Даниил 2', 'Даниил 3'],
				sayHello(){
					this.names.forEach(element => {
						setTimeout(() => {
							console.log('Привет, я - ${this.names}')
						}, 1000)
					})
				}
			}
			где, 
				sayHello - название свойства, являющееся функцией
				() => {}	- синтаксис стрелочной функции

			Здесь функция setTimeout() не имеет привязки к объекту. Поэтому может ссылаться только на глобальный объект windiw.
			Если бы collback функция имеала вид "function(){}", то ее контекст был обращен к контексту глобального объекта (window) по-умолчанию если у родителя объекта не будет. 
			Простую collback функцию можно было бы привязать у нужному объекту записью "function().bind(user){}", но эта запись довольно громозкая.
			Другое дело стрелочная функция () => {}. Она не имее своего контекста и копирует ближайший внешний this (ссылку на объект).
			Ближайший внешний this есть у sayHello: "this.names.forEach", а контекст names.forEach ссылается на user.
			Значит запись ${this.names} будет ссылаться на объект user без прописки контекста. 

			ИТОГО: Стрелочная функция обычно используется, когда в методе у объекта нужно вызвать какой либо обработчикили функцию (например setsetTimeout() как в примере).

			Пример с объявлением однострочной стрелочной функции:
				let getMessage = (text, name) => text + ', ' + name + '!';
				console.log(getMessage(Привет, Вася));
			Результат функции: 'Привет, Вася!'.
			Пример с объявлением многострочной стрелочной функции:
				let getMessage = (text, name) => {
					return text + ', ' + name + '!';
				};
		*/
//функция не принимающая параметры
let noInFunction = 'Значение переменной вне функции';
function show() {
	var el = "SHalom";
		console.log(noInFunction);
	}
show();

//функция принимающая параметры

function calc(a=5, b=5) {
	var res = a + b;
	console.log('Сумма чисел: '+res);
}

calc(70, 7);
let new_calc = calc;
new_calc(); //псевдоним функции calc();
new_calc = null; //обнуление псевдонима функции calc();

//ЗАПИСЬ РЕЗУЛЬАТАТ ФУНКЦИИ В ПЕРЕМЕННУЮ
	function multiply(a, b, c) {
		var res = a * b * c;
		return res;
}
let mult = multiply(3, 3, 3);
console.log('Результат умножения функции: ' + mult);

//ПРОВЕРКА МАССИВА НА НАЛИЧИЕ ВСЕХ ЧЕТНЫХ ЗНАЧЕНИЙ
function arrayEven(array_function) {
	let isEven = true;
	array_function.forEach(function(item, i, array){
		if (item % 2 != 0) {
			isEven = false;
		}
	});	
	return isEven;
}

let ar_ = [5, 9, 0, 4];
let ar_2 = [6, 8, 2, 10];

let isEven = arrayEven(ar_2); //конфликта не должно быть от с переменной функции, так как она в ней локальная
console.log('Результа перебора массива в функции: ' + isEven);

//СОЗДАНИЕ ФУНКЦИИ БЕЗ ВОЗМОЖНОСТИ ВЫЗОВА ДО ОБЪЯВЛЕНИЯ
let func_2 = function(name = 'Fred') {
	console.log('Вызов более строгой функции: '+name);
}
func_2('Dgone');


//ВЫЗОВ ФУНКЦИИ С ЗАДЕРЖКОЙ
function funct_time(t) {
	console.log('Функция вывведется через 1.5, 2, 2.5 сек...');
	console.log(t);
}
setTimeout(funct_time, 1500, 'выведено_1');  											//первый вариант прописи функции setTimeout
setTimeout("console.log('выведено_2')", 2000); 											//второй вариант прописи функции setTimeout
let timeOut = setTimeout(function () { console.log('выведено_3'); }, 2500);	//третий вариант прописи функции setTimeout

//УДАЛЕНИЕ ЗАДЕРЖКИ ВЫПОЛНЕНИЯ ФУНКЦИИ
clearTimeout(timeOut); //теперь функция в переменной "timeOut" не запускается без прямого вызова

/*вызов функции через 3 секунды, где
	setTimeout					- функция с отчетом запуска функции-аргумента, 
	clearTimeout,				- функция удаления задержки выполнения функции (отменяет setTimeout),
	funct_time					- функция аргумент, 
	3000							- время задержки вызова 
	выведено						- аргумент выводимой функции
	console.log('Привет')	- кусок кода JS
*/

//ПЕРИОДИЧЕСКИЙ ВЫЗОВ ФУНКЦИЙ
let interval = setInterval(func_2, 3000, 'Запуск через функцию "setInterval"');

//Завершение периодического запуска
setTimeout(function () {
	clearInterval(interval);
	console.log('Периодический запуск отключен');
}, 5000);
/*
Форматы записи аргумента в функцию "setInterval" такие же как в "setTimeout".
где,
	setInterval	- функция запускающая функцию-аргумент периодечески
	funct_time	- функция-аргумент
	3000			- интервал запуска
	Переиодически запускающаяся функция "setInterval" - аргумент функции аргумента
*/

/*ВАЖНО №1! Переменные созданные в функции - не видны зха ее пределами
	Хоть переменная "el" и создана через оператор "var", но она не видна за пределами тела функции. 
	Переменные созданные в функции называются локальными и видны только в пределах функции в которой созданы.

ВАЖНО №2! Функция может выводить переменные, не являющиеся аргументами
	Внешние переменные - переменные, созданные за пределами функции. 
	При этом если внешнюю переменные не вставлять как аргумент функции (calc(a){...}), но выводить в ней переменную черезх консоль (calc(){console.log(a);}) - они будут выводиться, даже если созданы через оператор "let", так и "var".

ВАЖНО №3! Функции могут запускаться без ошибок при отсутсттвии аргумнетов
	В JS функциии, созданные с принятием аргументов - могут запускаться без ошибок при отсутствии переданных в них аргументов. Например функция сложения двух чисел. 
	Если не передавать всех аргументов при вызове функции - из значение определится как "undefined".
	Поэтому на такие случаи в функции запускается проверка на наличии в переменных значения "undefined" и присваения им другого определенного значчения. 
	Но это можно указывать и прямо в условии функции: calc(a, b=5) => если b не определено, то выбирать значение 5 по-умолчанию. 

ВАЖНО №4! Псевдонимы функций
	Фунции можно переименовывать,задавая им псевданим:
		let new_calc = calc(); => это помещение результата функции в переменную "new_calc"
		let new_calc = calc; => это создание псевдонима функции "calc", вызывая который - вызывается функция "calc()";
		new_calc(); == calc();
	Так же псевдоним можно обнулить: new_calc = null; 

ВАЖНО №5! Способы создания функций
	В JS классический способ создания функции позволяет вызывать ее и до ее объявления - ошибка выводится не будет.
		new_funct(arg);
		function new_funct(arg){...}
	НО Если создать функцию в таком формате - ее вызов будет возможен только после объявлении функции:
		let func_2 = function(name = 'Fred') {
			console.log('Вызов более строго функции: '+name);
		}
		func_2('Dgone');
*/

//#1.9 - Взаимодействие с пользователем
console.log('');
console.log('#1.9 - Взаимодействие с пользователем');
/*Введение:
	Рассмотрим 3 функции для взмимодействия с пользователем
	а) alert(); 	- функция JS, принимающая в качестве аргумента текс, отобращающегося в сплывающем окне. 
		Как правиль в реальных проектах команда alert(). Она в основном используется для вывода некоторых данных при изучении языка JavaScript.
	б) prompt();	- функция JS, спрашивающая данные у поьзователя. Например возраст. 
		Первым параметром выступает заголовок окна, вторым - значенеи по-умолчанию в поле (параметр не обязателен). Окно имеет кнопуи "Отмена" и "Ок". 
		Полученные данные от пользователя можно поместить в переменную, если функцию "prompt" предварительно поместить в переменную. 
	в) confirm();	- функция JS, вызывающее окно с вопросом к пользователя. Обычно выводится для ответа да или нет.  
		Результат функции так же можно помещать в переменную. 
*/
//var alert_num_test = 55;
//alert('Число, выведенный через функцию alert(): '+alert_num_test);

//let getUserInfo = prompt('Сколько вам лет?', 24);
//alert('Ваш возраст: '+getUserInfo);

//let isConfirm = confirm('Согласны ли вы на обработку персональных данных?');
//alert('Ответ на запрос обработки данных: '+isConfirm);


//#1.10 - Объекты и классы
console.log('');
console.log('#1.10 - Объекты и классы');
/*Введение:
		ОБЪЕКТ - это тип данных, кторый описывает какой либо объект с его параметрами.
			Массив под эти нужны не годится, так как ключамизначений  выступают индексы - цифры. 
			Объект создается через фигурные скобки {}, в которых перечислыины пары свойство-значение. Color: red, ...
			Значенеи объекта выводится чередз обращение к свойству. 

		КЛАСС - это коснтрукция на основе которой можно создавать множество объектов. 
			Классы создаются либо через класс либо через функцию. Рекомендуется создавать класс через класс с конструктором.
			Создание класса еще не создает объект.Но на его основе можно создать объект. 
			Чтобы создать объект на основе класса - нужно создать переменную, на основе созданного класса, передавая аргументы, соответствующие свойствам/полям класса.
			Классы используются для создания множественного создания больших объектов. 
			Класс помимо свойств объекта может подразумевать наличие функций. Объекты на основе класса - имеют доступ к этой функции. 
			Даже для объекта, созданного на основе класса - допустимо создавать новые свойства вне класса.

			*/
//ОБЪЕКТЫ
let obj_car = {
	color: 'red',
	mass: 5000,
	speed: 250,
	fuel: 50,
	year: 5,
	isNew: true,
	power:  90,
	passengers:  ['Alex', 'Bob', 'John'],
};

//Способы вывода значния объекта
console.log(obj_car.speed); 	//первый способ вывода значения объекта
console.log(obj_car['year']);	//второй способ вывода значения объекта

//ЦИКЛ forIn
console.log('');
for (let key in obj_car) {
	console.log('Элемент по ключу '+key+': '+obj_car[key]);
}
/*где,
	key 		- созданная переменная, которая является псевдонимом свойства объекта. Обращаются к ней в цикле только так: "car[key]".
	obj_car	- перебираемый объект
*/

//КЛАССЫ
	//Создание класса на основе функции
	function CarFunctionClass(marka, color, type, speed) {
		this.marka = marka;
		this.color = color;
		this.type =  type;
		this.speed = speed;	
	}
	/*где,
		marka						- получаемый классом аргумент 
		this.marka				- поле класса
		this.marka = marka;	- присвоение аргумента к полю класса
	*/	
	//Создание класса на основе класса
		class CarClassClass{
			//создание конструктора
			constructor(weight, length, width, height) {
				this.weight = weight;
				this.length = length;
				this.width =  width;
				this.height = height;					
			}

			//функция класса
			info() {
				console.log('Вывод объекта через функцию => '+'Вес: '+this.weight, 'Длина: '+this.length, 'Ширина: '+this.width, 'Выстота: '+this.height);
			}
		}

	//Создание объекта на основе класса
		let bmw = new CarFunctionClass('V5', 'Green', 'BMW', '290');
		let volvo = new CarFunctionClass('G3', 'Red', 'volvo', '240');
		let par = new CarClassClass('2 т.', '3.5 м.' , '2 м.', '1.5 м.');
		//присвоение свойству объекта нового значения
		volvo.color = 'Yelow';
			console.log('Вывод объекта "bmw": '+bmw['type']);
			console.log('Вывод объекта "volvo": '+volvo['color']);
			console.log('Вывод объекта "par": '+par['width']);
			
		//добавление нового свойства объекту
		bmw.weight = '1.8 т.';
		console.log('Вывод нового созданного свойства объекта: '+bmw.weight);
		
		//вызов функции класса
		par.info();
		
	

//#1.11 - Формат JSON
console.log('');
console.log('#1.11 - Формат JSON');
/*Введение:
	JSON - формат данных в виде объекта, понимаемый как беком так и фронтом.
		Этот формат используется, чтобы передавать данные серверу - back и обратно на клиент - front. 
		И на фронте и на беке есть функции перевода объекта в JSON и JSON в объект. 
		JSON объект хоть и объект, но работать с ним как с объектом не получится - придется переводить в объект обычный. 
		JSON может иметь и форму массива. 
		
	JSON-объект отличается от обычного объекта большей строгостью:
		а) В JSON объекте более строгая типизация:
			В JSON все ключи и значения (кроме bool и int) обязательно прописываются в двойных ковычках, в то время как простой объект может писаться и с ними и без. 
		б) JSON объект заключается в одинарные кавычки. Т.е. по-сути JSON объект - это строка, похожая на объект/массив. 
		
	Функции работы с JSON:
		JSON.parse()		- функция перевода JSON объекта/массива в обычный объект. Аргументом выступает JSON объект. 
		JSON.stringify()	- функция перевода обычного объекта в JSON объекта/массив. Аргументом выступаеют: 
			а) Переводимый в JOSN объект
			б) Массив с свойствами объекта, входящими в JSON. При отсутствии аргумента - в JSON переводятся все свойства объекта. 
			в) ИНтервал в пробелах, задаваемый каждому свойству в JSON. Т.е. насколько свойства будут отступать от  фигурных скобок объекта JSON.
*/

//создание JSON объенкта
let json_obj = '{"name": "Jone", "age": 46, "hasCar": true, "numeric": [1, 2, 3, 4, 5]}';
	console.log('JSON объект: '+json_obj);
	
//JSON объект как массив
let array_JSON = '[25, "y3", "typ"]';
	console.log('Вывод JSON в виде массива: ' + array_JSON);

//функция перевода JSON объекта/массива в обычный объект
let json_objNorm = JSON.parse(json_obj);
	console.log('Обычный объект из JSON-объекта: ' + json_objNorm.numeric[3]);

let json_objNormA = JSON.parse(array_JSON);
	console.log('Обычный объект из JSON-массива: ' + json_objNormA[0]);

//функция пееревода объекта в JSON объект
let obj_json = JSON.stringify(json_obj);
		console.log('Вывод переведенного JSON из объекта: '+obj_json);

//ниже вывыодятся функции периодисечкие и с задержкой
console.log('');
console.log('Ниже вывыодятся функции периодисечкие и с задержкой');
